<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const log = document.getElementById('log');
const alertSound = document.getElementById('alert-sound');

const line1 = 120;
const line2 = 260;
const distanceMeters = 10;

let model;
const vehicleData = [];
const trackers = {};
let trackerId = 0;

// Track Object
class TrackedObject {
  constructor(id, x, y) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.startTime = null;
    this.endTime = null;
    this.lastUpdate = Date.now();
  }
  update(x, y) {
    this.x = x;
    this.y = y;
    this.lastUpdate = Date.now();
  }
}

// Match detections to trackers
function matchAndTrack(predictions) {
  const matched = new Set();
  for (const pred of predictions) {
    const [x, y, w, h] = pred.bbox;
    const cx = x + w / 2;
    const cy = y + h / 2;

    let bestMatch = null;
    let minDist = 50;
    for (const id in trackers) {
      const t = trackers[id];
      const dx = cx - t.x;
      const dy = cy - t.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < minDist && !matched.has(id)) {
        bestMatch = id;
        minDist = dist;
      }
    }

    if (bestMatch) {
      trackers[bestMatch].update(cx, cy);
      pred.trackerId = bestMatch;
      matched.add(bestMatch);
    } else {
      trackerId++;
      trackers[trackerId] = new TrackedObject(trackerId, cx, cy);
      pred.trackerId = trackerId;
    }
  }
}

// Camera Access
navigator.mediaDevices.getUserMedia({
  video: { width: 480, height: 360, facingMode: "environment" }
}).then(stream => {
  video.srcObject = stream;
}).catch(err => {
  log.innerHTML = `<p style="color:red;">‚ùå Camera not accessible.</p>`;
});

// Load model
cocoSsd.load().then(loaded => {
  model = loaded;
  log.innerHTML = "‚úÖ Model Loaded - Detecting Vehicles...";
});

// Detection loop (reduced FPS)
video.addEventListener('play', () => {
  setInterval(async () => {
    if (!model) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    // Draw lines
    ctx.strokeStyle = 'red';
    [line1, line2].forEach(line => {
      ctx.beginPath();
      ctx.moveTo(0, line);
      ctx.lineTo(canvas.width, line);
      ctx.stroke();
    });

    const predictions = await model.detect(video);
    const vehicles = predictions.filter(p => ['car','truck','motorcycle','bus'].includes(p.class) && p.score > 0.7);

    matchAndTrack(vehicles);

    for (const pred of vehicles) {
      const [x, y, w, h] = pred.bbox;
      const cx = x + w / 2;
      const cy = y + h / 2;
      const id = pred.trackerId;
      const tracker = trackers[id];

      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'lime';
      ctx.fillText(`${pred.class.toUpperCase()} (${id})`, x, y - 5);

      if (!tracker.startTime && cy >= line1) {
        tracker.startTime = Date.now();
      }

      if (tracker.startTime && !tracker.endTime && cy >= line2) {
        tracker.endTime = Date.now();
        const timeTaken = (tracker.endTime - tracker.startTime) / 1000;
        const speed = (distanceMeters / timeTaken) * 3.6;
        const timestamp = new Date().toLocaleString();

        log.innerHTML = `<p>${speed > 60 ? '‚ö†Ô∏è Over Speed' : '‚úÖ OK'} ‚Äî <strong>${pred.class.toUpperCase()}</strong>: ${speed.toFixed(2)} km/h</p>`;
        if (speed > 60) alertSound.play();

        // Run OCR only once per vehicle
        const plateCanvas = document.createElement('canvas');
        plateCanvas.width = w;
        plateCanvas.height = h;
        plateCanvas.getContext('2d').drawImage(video, x, y, w, h, 0, 0, w, h);

        Tesseract.recognize(plateCanvas, 'eng').then(result => {
          const number = result.data.text.trim().replace(/\s+/g, '') || 'N/A';
          log.innerHTML += `<p>üîç Plate: <strong>${number}</strong></p>`;
          vehicleData.push({
            type: pred.class.toUpperCase(),
            speed: speed.toFixed(2),
            plate: number,
            time: timestamp
          });
        });

        setTimeout(() => delete trackers[id], 3000);
      }
    }
  }, 200); // run detection every 200ms (~5 FPS)
});

function exportCSV() {
  if (!vehicleData.length) {
    alert("No data to export.");
    return;
  }
  const headers = "Vehicle Type,Speed (km/h),Number Plate,Timestamp\n";
  const rows = vehicleData.map(v => `${v.type},${v.speed},${v.plate},${v.time}`).join("\n");
  const blob = new Blob([headers + rows], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "vehicle_speed_log.csv";
  link.click();
}

function resetData() {
  vehicleData.length = 0;
  for (let id in trackers) delete trackers[id];
  log.innerHTML = "üîÅ Tracker reset.";
}
</script>
